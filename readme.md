### Консольная утилита, распаралеливающая долгий запрос на чтение из БД с последующей выгрузкой результатов в файл.

* Класс **AppSettings** - предназначен для чтения настроек из xml файла:
  * текст распараллеленного sql;
  * количество потоков выполнения;
  * тип формируемого отчета, (пока ограничусь csv);
  * писать ли шапку отчета;
  * кодовая страница отчета
  * имя файла отчета
  * url соединения с БД

  Источник загрузки настроек определяется типом перечисления SettingsType.

  В проекте реализована загрузка параметров из XML файла.

  Логин и пароль соединения с БД из соображений безопасности, читаю из System.getProperties, (командная строка).

* Класс **DBCPDataSource** открывает пул соединений с PostgreSQL, реализован через org.apache.commons.dbcp.BasicDataSource.

* Класс **DataProducer** запускает заданное количество задач, (потоков) с распараллелеными запросами к БД.
  
  Количество запущенных запросов определяется параметром из настроек threadsCount.

  Результаты работы каждого запроса в потоке построчно выгружается в очередь сообщений BlockingQueue<String>, на основе LinkedBlockingQueue.

  После окончания работы всех SQL запросов к БД, в очередь посылается сообщение "отравленная пилюля" POISON_PILL - сигнал читателю очереди окончить работу.

* Класс **Consumer**, открывает csv файл отчета на запись в отдельном потоке, затем  в цикле читает строки из очереди сообщений BlockingQueue<String> и записывает в файл отчета.

  Цикл чтения прерывается после получения сообщения POISON_PILL.

* **БД: PostgreSQL**. Исходный запрос к тестовой таблице возвращает 500_000 строк. Каждая строка содержит primary key id типа id serial4 NOT NULL.

  Распаралеливание исходного запроса на SQL подзапросы реализовано при помощи добавления в SQL условия разбиения на подзапросы : where mod(id, threadCounter) = 0..threadCounter - 1
  
* **Полученные результаты:**
  
  Как показали полевые испытания, время формирования файла отчета при помощи 1-го потока иногда работает сопоставимо со временем для 4-х потоков. Полученный результат могу объяснить неудачным выбором SQL, который недостаточно сильно нагрузил поток.

   На скорость формирования файла отчета влияет емкости очереди. 
  
   Протестирован запуск утилиты с командной строки: java.exe -Dlogin=postgres -Dpassword=123 -Dfile.encoding=UTF-8 -jar C:\work\Otus\db-upploader-coursework\target\db-upploader-jar-with-dependencies.jar

   Логи запусков с разными конфигурациями утилиты по потокам приложены.